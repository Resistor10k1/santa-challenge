<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<h1 id="santa-challenge">Santa Challenge</h1>
<p><img src="https://github.com/Resistor10k1/santa-challenge/actions/workflows/santa-challenge-unit-tests.yml/badge.svg" /></p>
<h2 id="introduction">Introduction</h2>
<p>In the context of a algorithms course, the santa challenge could be solved as a voluntary exercise. This repository contains the code and a short description on how the exercise is solved. This challenge has originally been uploaded to <a href="https://www.kaggle.com/competitions/santas-stolen-sleigh" target="_blank">kaggle.com</a> in 2016.</p>
<p>See <a href="#goal">Goal</a> for the description of the problem, which is basically just the description found on <a href="https://www.kaggle.com/competitions/santas-stolen-sleigh" target="_blank">kaggle.com</a>.</p>
<p>See <a href="#result">Result</a> for the result achieved with the code in this repository.</p>
<h3 id="goal">Goal</h3>
<p>Help Santa distribute the gifts all over the world. Therefore, the overall weighted-reindeer-weariness (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>R</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">WRW</annotation></semantics></math>) must be minimized. All sleigh trips start at the North-Pole (Lat=90, Long=0), then head to each gift in a specified order, and finally head back to the North-Pole. Santa’s sleigh has a base weight of 10 and a weight limit of 1000 (excluding the sleigh base weight).</p>
<p>The weighted-reindeer-weariness is calculated with the following folmula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>R</mi><mi>W</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>j</mi></msub></munderover><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mi>i</mi></mrow><msub><mi>n</mi><mi>j</mi></msub></munderover><msub><mi>w</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>*</mo><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>o</mi><msub><mi>c</mi><mi>i</mi></msub><mo>,</mo><mi>L</mi><mi>o</mi><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">WRW = \sum_{j=1}^m \sum_{i=1}^{n_j} \sum_{k=i}^{n_j} w_{kj} * Dist(Loc_i, Loc_{i-1})</annotation></semantics></math></p>
<p>Where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is the number of trips, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">n_j =</annotation></semantics></math>(#gifts for trip <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>)<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">w_{ij}</annotation></semantics></math> is the weight of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th gift at trip <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Loc_i</annotation></semantics></math> is the location of gift <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Loc_0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><msub><mi>n</mi><mi>j</mi></msub></msub></mrow><annotation encoding="application/x-tex">Loc_{n_j}</annotation></semantics></math> are the North-Pole, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">w_{n_{j},j}</annotation></semantics></math> (the last leg of each trip) is always the base weight of the sleigh.</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>o</mi><msub><mi>c</mi><mi>i</mi></msub><mo>,</mo><mi>L</mi><mi>o</mi><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Dist(Loc_i, Loc_{i-1})</annotation></semantics></math> function returns the Haversine distance <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math> between location <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math>.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ϕ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\phi_1, \phi_2</annotation></semantics></math> : Latitude of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Loc_1</annotation></semantics></math> resp. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Loc_2</annotation></semantics></math> in radians<br> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_1, \lambda_2</annotation></semantics></math> : Longitude of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Loc_1</annotation></semantics></math> resp. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Loc_2</annotation></semantics></math> in radians<br> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> : Radius of the earth (6371.0087714km)</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>2</mn><mi>r</mi><mo>arcsin</mo><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mrow><msup><mo>sin</mo><mn>2</mn></msup><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><msub><mi>ϕ</mi><mn>2</mn></msub><mo>−</mo><msub><mi>ϕ</mi><mn>1</mn></msub></mrow><mn>2</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>ϕ</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mo>sin</mo><mn>2</mn></msup><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><msub><mi>λ</mi><mn>2</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>1</mn></msub></mrow><mn>2</mn></mfrac><mo stretchy="false" form="postfix">)</mo></mrow></msqrt><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> d = 2r \arcsin \left( \sqrt {\sin^2 ({\frac{\phi_2-\phi_1}{2}}) + \cos(\phi_1)\cos(\phi_2) \sin^2 ({\frac{\lambda_2-\lambda_1}{2}})} \right) </annotation></semantics></math></p>
<h4 id="example">Example</h4>
<p>Two gifts <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> are delivered in a trip. Then the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>R</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">WRW</annotation></semantics></math> is calculated as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mo>North-Pole</mo><mo>→</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>_</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>_</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>→</mo><mo>North-Pole</mo><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>_</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\newcommand{\NorthPole}{\operatorname{North-Pole}}
\begin{aligned}
&amp;Dist(\NorthPole \rightarrow A) &amp;&amp;* (base\_weight + weight(B) + weight(A))&amp;&amp; \\
&amp;Dist(A \rightarrow B) &amp;&amp;* (base\_weight + weight(B))&amp;&amp; \\
&amp;Dist(B \rightarrow \NorthPole) &amp;&amp;* (base\_weight)&amp;&amp;
\end{aligned}
</annotation></semantics></math></p>
<h2 id="solution-approach">Solution approach</h2>
<p>In a first step, all gifts are sorted by the distance to the North-Pole in ascending order. Starting with the closest gift, the tours are built with Nearest-Neighbour approach. For each tour, a Simulated Annealing algorithm is run, to improve the tour.</p>
<h2 id="result">Result</h2>
<p>For verifing the solution a Jupyter notebook provided by the lecturer is used. The achieved weighted-reindeer-weariness is 13’485’852’013.1237 in 1430 trips.</p>
<h2 id="code">Code</h2>
<p>All code is written in C++. For a detailed code documentation refer to the <a href="https://resistor10k1.github.io/santa-challenge/" target="_blank">wiki</a></p>
<h2 id="some-other-ideas">Some other ideas</h2>
<p>In general, just find ‘a’ solution and then try to improve it with local improvements such as <em>k-opt Neighbourhood</em>, <em>Randomized Local Search</em> or <em>Simulated Annealing</em>.</p>
<h3 id="how-to-find-a-solution">How to find ‘a’ solution</h3>
<ol type="1">
<li>Fill the sleigh with knapsack and the closest locations and optimize with some TSP algorithm.</li>
<li>K-means clustering to group the locations which are close to each other. Apply some threshold (heuristics) for maximum distance within the group and also check that the sleigh weight is not exceeded. Start with the locations furthest away and optimize with some TSP algorithm.</li>
</ol>
<h3 id="just-some-idea-for-the-algorithm">Just some idea for the algorithm</h3>
<p><em>How to cluster:</em><br> 1. <em>Take the closest point p0 and add it to the sleigh.</em> 2. <em>Check if the sleigh still has space and add the closest point to p0 to the sleigh. Repeat.</em> 3. <em>Solve TSP locally in the found point subset. The two closest point to the pole are the start resp. end points.</em> 4. <em>Restart</em></p>
</body>
</html>
